<!DOCTYPE html><html lang="cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>超简短的独立游戏开发教学 | Sparkle</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main style="flex-direction: row-reverse"><article><div id="post-bg"><div id="post-title"><h1>超简短的独立游戏开发教学</h1><hr></div><div id="post-content"><h1 id="Ep-01-还不懂游戏开发？"><a href="#Ep-01-还不懂游戏开发？" class="headerlink" title="Ep.01 还不懂游戏开发？"></a>Ep.01 还不懂游戏开发？</h1><h1 id="Ep-02-工欲善其事，必先利其器"><a href="#Ep-02-工欲善其事，必先利其器" class="headerlink" title="Ep.02 工欲善其事，必先利其器"></a>Ep.02 工欲善其事，必先利其器</h1><h1 id="Ep-03-想开发独立游戏，一定要先学好编程吗？"><a href="#Ep-03-想开发独立游戏，一定要先学好编程吗？" class="headerlink" title="Ep.03 想开发独立游戏，一定要先学好编程吗？"></a>Ep.03 想开发独立游戏，一定要先学好编程吗？</h1><h1 id="Ep-04-一个视频，带你上道游戏编程"><a href="#Ep-04-一个视频，带你上道游戏编程" class="headerlink" title="Ep.04 一个视频，带你上道游戏编程"></a>Ep.04 一个视频，带你上道游戏编程</h1><h1 id="Ep-05-从无到有，制作一个游戏小样"><a href="#Ep-05-从无到有，制作一个游戏小样" class="headerlink" title="Ep.05 从无到有，制作一个游戏小样"></a>Ep.05 从无到有，制作一个游戏小样</h1><h1 id="Ep-06-规则的千变万化！超迷你关卡设计"><a href="#Ep-06-规则的千变万化！超迷你关卡设计" class="headerlink" title="Ep.06 规则的千变万化！超迷你关卡设计"></a>Ep.06 规则的千变万化！超迷你关卡设计</h1><h1 id="Ep-07-一次看过-Unity-常用组件"><a href="#Ep-07-一次看过-Unity-常用组件" class="headerlink" title="Ep.07 一次看过 Unity 常用组件"></a>Ep.07 一次看过 Unity 常用组件</h1><h1 id="Ep-08-UI-还能长什么样？"><a href="#Ep-08-UI-还能长什么样？" class="headerlink" title="Ep.08 UI 还能长什么样？"></a>Ep.08 UI 还能长什么样？</h1><h1 id="Ep-09-草履虫也能看懂的乐理入门"><a href="#Ep-09-草履虫也能看懂的乐理入门" class="headerlink" title="Ep.09 草履虫也能看懂的乐理入门"></a>Ep.09 草履虫也能看懂的乐理入门</h1><h1 id="Ep-10-为了讲故事创造一个世界？"><a href="#Ep-10-为了讲故事创造一个世界？" class="headerlink" title="Ep.10 为了讲故事创造一个世界？"></a>Ep.10 为了讲故事创造一个世界？</h1><h1 id="Ep-11-敲代码是为了不敲代码？"><a href="#Ep-11-敲代码是为了不敲代码？" class="headerlink" title="Ep.11 敲代码是为了不敲代码？"></a>Ep.11 敲代码是为了不敲代码？</h1><h1 id="Ep-12-一心二用的妙用"><a href="#Ep-12-一心二用的妙用" class="headerlink" title="Ep.12 一心二用的妙用"></a>Ep.12 一心二用的妙用</h1><p>Time: 2021-10-15</p>
<p>代码并行有两种方案：<strong>多线程 (Multithreading)<strong>、</strong>协程 (Coroutine)</strong></p>
<p>程序运行在一条线程上，由 CPU 的一个核心按顺序逐行执行。</p>
<p>多线程的思路即是开辟一条新的线程，将其中包含的程序指令交给 CPU 的另一个核心来执行，通过同时运算来实现并行。</p>
<p>当 CPU 只有一个核心则无法实现这种真正的并行，此时 CPU 会飞快地在两个线程之间反复横跳营造出一种宏观上的并行，最终需要花费的时间是两个线程各自所需时间之和外加切换线程需要的时间消耗。这种宏观上同时执行、微观上切分时间轮换执行的形式称为并发。</p>
<p>协程和并发类似，通过在一个线程内的轮换调度同时完成多个任务。虽然并不能减少各个任务消耗的时间，但节约了切换线程需要的时间消耗，效率高于单核情况下的多线程。</p>
<p>对于游戏引擎，协程的使用频率一般要远大于多线程，这和游戏程序的特性有关。而且引擎对多线程的使用也作出了一些限制。如在 Unity 中与 Unity 有关的 API 及绝大部分数据类型都需要放置在主线程上执行否则就会报错。一般只有诸如网络请求、大量文件读写或者非常耗时的数据运算才会放在新的线程上，其中的内容通常是与 Unity 无关的原生代码。</p>
<p>上一节中展示的代码延迟执行、网络请求、相机平滑都是给予协程实现的。</p>
<p>协程的写法非常简单：</p>
<ul>
<li>首先定义一个用作协程的方法，返回值为 <code>IEnumerator</code>，关于这个类型可以作为固定写法记录，只要是协程方法返回值都是 <code>IEnumerator</code>，感兴趣可以深入了解 C# 的接口和迭代器的概念。</li>
<li>根据需要定义方法名和参数列表。如 <code>IEnumerator XplusY(int x, int y)</code>在生命周期函数中，使用 Startcorountine 方法即可开启协程。括号中填入声明的协程方法，协程就会执行。</li>
</ul>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Start()&#123;
    StartCorountine(XplusY(1,1))
&#125;</code></pre>

<p>通常放在协程里执行的代码都是一些需要消耗时间的操作，比如资源加载、网络请求或者单纯等待一段时间。所以方法内部对于这些需要等待的操作，前面需要加上 <code>yield return</code> 关键字来延迟执行。</p>
<ul>
<li><p>等待指定时间</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator XplusY(int x, int y)&#123;
    yield return new WaitForSeconds(10);
    print(&quot;两数十秒后相加为&quot; + (x+y));
&#125;</code></pre></li>
<li><p>等待数据加载完成</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator LoadResource()&#123;
    RescourceRequest r &#x3D; Resources.LoadAsync(&quot;方圆 500 米山脉&quot;);
    yield return r;
&#125;</code></pre></li>
<li><p>等待网络请求返回结果等等</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator AnnoyBaidu()&#123;
    UnityWebRequest r &#x3D; UnityWebRequest.Get(&quot;www.baidu.com&quot;);
    yield return r.SendWebRequest();
&#125;</code></pre></li>
</ul>
<p>在执行到 <code>yield return</code> 时，协程的内容会被挂起，程序会先去处理别的逻辑。一旦 <code>yield return</code> 后的等待完成，如资源加载完毕、请求返回了结果、计时完毕，就会继续执行 <code>yield return</code> 这行之后的代码，直到执行完方法里的每一行代码，这个协程就会完成并退出。</p>
<p><code>yield return</code> 加等待操作这样的代码在一个协程内是可以写很多行的，甚至可以写一个循环，并在每次循环的时候等候一帧来模拟 <code>Update</code> 方法的效果。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator YourCoroutine()&#123;
    while(true)&#123;
        &#x2F;&#x2F; 返回 null 则等待一帧
        yield return null;
    &#125;
&#125;</code></pre>

<p>相机平滑移动工具脚本正是利用了这种思路。现在已经知道了如何让代码并发，但仍有一个问题：当协程里的代码和主线程代码同时执行时，主线程代码需要能知道协程中的代码是否执行完毕并将运行结果带回到主线程。</p>
<p>为了实现这一需求，需要引入一个新的概念——**回调 (Callback)**，需要在协程执行完之后或者在执行过程中向主线程反馈情况，C# 提供了一个叫做委托的功能，类似于 C++ 中的函数指针。通过声明、定义和发布委托的形式可以实现消息通知功能。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate void Call();
Call phoneCall;
phoneCall.Invoke();</code></pre>

<p>C# 封装好了一个数据类型 <code>Action</code>，引入 <code>System</code> 命名空间，在协程的参数列表中定义一个 <code>Action</code> 类型的参数，如 <code>callback</code>，然后在协程的代码中根据需要在合适的地方使用 <code>Invoke</code> 方法发布消息。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Using System;
IEnumerator Coro(Action callback)&#123;
    yield return ...;
    callback.Invoke();
&#125;</code></pre>

<p>如果发布消息还需要传递数据出去，在定义时在 <code>Action</code> 后面加上尖括号并填写数据类型，在 <code>Invoke</code> 方法的参数括号里带上需要传递出去的数据即可。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Using System;
IEnumerator Coro(Action&lt;string&gt; callback)&#123;
    yield return ...;
    callback.Invoke(&quot;It&#39;s over&quot;);
&#125;</code></pre>

<p>开启协程时，在参数这里可以直接填入一个方法，当 <code>callback</code> 被发布时就会调用这个方法，实现对协程内运行情况的监听。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Start()&#123;
    StartCorountine(Coro(Handler));
&#125;

void Handler(string message)&#123;
    print(message);
&#125;</code></pre>

<p><code>Action</code> 的使用场景很广泛，可以非常方便地发送各种事件</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果有需要同时执行的代码，定义一个返回值类型为 <code>IEnumerator</code> 的协程方法：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator YourCoroutine()</code></pre>

<p>然后在其中写上需要并发的代码。<br>对于需要等待的操作，前面使用 <code>yield return</code> 延迟返回。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">IEnumerator YourCoroutine()&#123;
    yield return ...;
&#125;</code></pre>

<p>使用 <code>StartCoroutine</code> 方法开启协程，调用你的协程方法。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Start()&#123;
    StartCorountine(YourCoroutine());
&#125;</code></pre>

<p>如果主线程需要对协程运行情况进行监听，在协程方法的参数列表中加入 <code>Action</code> 变量，在合适的地方使用 <code>Invoke</code> 方法发布事件。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Using System;
IEnumerator YourCoroutine(Action callback)&#123;
    yield return ...;
    callback.Invoke();
&#125;</code></pre>

<p>然后在 <code>StartCoroutine</code> 后面的方法调用里填入一个方法作为参数来监听这个事件，实现对协程方法运行情况的监控。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Start()&#123;
    StartCorountine(YourCoroutine(Handler));
&#125;

void Handler(string message)&#123;
    print(message);
&#125;</code></pre>

<p>尝试实现代码延迟执行的工具脚本：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Delayer.Instance.DelaySeconds(10, ()&#x3D;&gt;print(&quot;等了10秒&quot;));</code></pre>

<p>下一节以事件收发为基础，针对鼠标的交互事件制作工具脚本。</p><div id="paginator"></div></div><div id="post-footer"><hr><a href="/post/321a27c2/">← Prev 不正经风格讲解编程知识</a><span style="color: #fe2"> | </span><a href="/post/9415f108/">女同士とかありえないでしょと言い張る女の子を、百日間で徹底的に落とす百合のお話 01 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://cdn.jsdelivr.net/gh/Sparklesyo/Collections/img/FNnex.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr. Sparkle</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">29</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">20</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">17</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-01-%E8%BF%98%E4%B8%8D%E6%87%82%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Ep.01 还不懂游戏开发？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-02-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">Ep.02 工欲善其事，必先利其器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-03-%E6%83%B3%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E5%85%88%E5%AD%A6%E5%A5%BD%E7%BC%96%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Ep.03 想开发独立游戏，一定要先学好编程吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-04-%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%B8%8A%E9%81%93%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Ep.04 一个视频，带你上道游戏编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-05-%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%EF%BC%8C%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E5%B0%8F%E6%A0%B7"><span class="toc-number">5.</span> <span class="toc-text">Ep.05 从无到有，制作一个游戏小样</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-06-%E8%A7%84%E5%88%99%E7%9A%84%E5%8D%83%E5%8F%98%E4%B8%87%E5%8C%96%EF%BC%81%E8%B6%85%E8%BF%B7%E4%BD%A0%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">Ep.06 规则的千变万化！超迷你关卡设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-07-%E4%B8%80%E6%AC%A1%E7%9C%8B%E8%BF%87-Unity-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">Ep.07 一次看过 Unity 常用组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-08-UI-%E8%BF%98%E8%83%BD%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">Ep.08 UI 还能长什么样？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-09-%E8%8D%89%E5%B1%A5%E8%99%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E4%B9%90%E7%90%86%E5%85%A5%E9%97%A8"><span class="toc-number">9.</span> <span class="toc-text">Ep.09 草履虫也能看懂的乐理入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-10-%E4%B8%BA%E4%BA%86%E8%AE%B2%E6%95%85%E4%BA%8B%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">Ep.10 为了讲故事创造一个世界？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-11-%E6%95%B2%E4%BB%A3%E7%A0%81%E6%98%AF%E4%B8%BA%E4%BA%86%E4%B8%8D%E6%95%B2%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">Ep.11 敲代码是为了不敲代码？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ep-12-%E4%B8%80%E5%BF%83%E4%BA%8C%E7%94%A8%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">Ep.12 一心二用的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">12.1.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><footer style="text-align: right"><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>